#!/usr/bin/env python3
from __future__ import annotations

import argparse
import hashlib
import pathlib
import subprocess
import sys


REPO_ROOT = pathlib.Path(__file__).resolve().parents[1]
STAMP_PATH = REPO_ROOT / "crates" / "timeseries-table-python" / "python-src.stamp"

WHEEL_INPUT_PREFIXES: tuple[str, ...] = (
    "python/pyproject.toml",
    "python/README.md",
    "python/src",
)


def _git_tracked_file_blobs() -> list[tuple[str, str]]:
    # Return (repo-relative posix path, git blob oid) pairs.
    #
    # Important: we hash git *blobs* (not working tree bytes) to avoid cross-platform differences
    # from git's line-ending conversion (core.autocrlf).
    try:
        out = subprocess.check_output(
            ["git", "-C", str(REPO_ROOT), "ls-files", "-s", "-z", *WHEEL_INPUT_PREFIXES],
            stderr=subprocess.DEVNULL,
        )
    except Exception:
        return []

    pairs: list[tuple[str, str]] = []
    for raw in out.split(b"\0"):
        if not raw:
            continue
        # Format: "{mode} {oid} {stage}\t{path}"
        try:
            meta, path_raw = raw.split(b"\t", 1)
            parts = meta.split()
            oid = parts[1].decode("ascii")
            path = path_raw.decode("utf-8")
        except Exception:
            continue
        pairs.append((path, oid))

    # Deterministic ordering, stable across platforms.
    return sorted(pairs, key=lambda t: t[0])


def _hash_inputs() -> tuple[str, int]:
    h = hashlib.sha256()
    blobs = _git_tracked_file_blobs()
    if not blobs:
        raise RuntimeError(
            "Could not find git-tracked inputs for stamp; run from a git checkout."
        )

    proc = subprocess.Popen(
        ["git", "-C", str(REPO_ROOT), "cat-file", "--batch"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
    )
    assert proc.stdin is not None
    assert proc.stdout is not None

    for _path, oid in blobs:
        proc.stdin.write(oid.encode("ascii") + b"\n")
    proc.stdin.close()

    for path, _oid in blobs:
        header = proc.stdout.readline()
        if not header:
            raise RuntimeError("Unexpected EOF from git cat-file --batch")
        # Format: "{oid} {type} {size}\n"
        try:
            _obj, obj_type, size_s = header.decode("ascii").rstrip("\n").split(" ", 2)
        except Exception as e:
            raise RuntimeError(f"Unexpected cat-file header: {header!r}") from e
        if obj_type != "blob":
            raise RuntimeError(f"Expected blob for {path}, got {obj_type}")
        try:
            size = int(size_s)
        except ValueError as e:
            raise RuntimeError(f"Unexpected blob size for {path}: {size_s!r}") from e

        content = proc.stdout.read(size)
        # cat-file outputs a trailing newline after the object content
        proc.stdout.read(1)

        h.update(path.encode("utf-8"))
        h.update(b"\0")
        h.update(content)
        h.update(b"\0")

    rc = proc.wait()
    if rc != 0:
        raise RuntimeError(f"git cat-file --batch failed with exit code {rc}")

    return h.hexdigest(), len(blobs)


def _read_stamp_sha256() -> str | None:
    if not STAMP_PATH.exists():
        return None
    for line in STAMP_PATH.read_text(encoding="utf-8").splitlines():
        if line.startswith("sha256:"):
            return line.split(":", 1)[1].strip()
    return None


def _write_stamp(sha256: str, *, file_count: int) -> None:
    STAMP_PATH.write_text(
        "\n".join(
            [
                "# Autogenerated by scripts/update_python_wheel_stamp.py",
                "# Hash of Python wheel sources (python/src + packaging metadata).",
                f"# inputs: {file_count} files",
                f"sha256: {sha256}",
                "",
            ]
        ),
        encoding="utf-8",
    )


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser(
        description="Update/verify the stamp that makes python-only changes visible to release automation."
    )
    ap.add_argument(
        "--check",
        action="store_true",
        help="Verify the stamp matches current python wheel inputs.",
    )
    args = ap.parse_args(argv)

    sha, n = _hash_inputs()
    current = _read_stamp_sha256()

    if args.check:
        if current == sha:
            return 0
        sys.stderr.write("python wheel stamp is out of date.\n")
        sys.stderr.write(f"expected sha256: {sha}\n")
        sys.stderr.write(f"current  sha256: {current or '<missing>'}\n")
        sys.stderr.write("\nFix:\n")
        sys.stderr.write("  python scripts/update_python_wheel_stamp.py\n")
        return 1

    _write_stamp(sha, file_count=n)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
