#!/usr/bin/env python3
from __future__ import annotations

import argparse
import hashlib
import pathlib
import subprocess
import sys


REPO_ROOT = pathlib.Path(__file__).resolve().parents[1]
STAMP_PATH = REPO_ROOT / "crates" / "timeseries-table-python" / "python-src.stamp"

WHEEL_INPUT_PREFIXES: tuple[str, ...] = (
    "python/pyproject.toml",
    "python/README.md",
    "python/src",
)


def _git_tracked_files() -> list[pathlib.Path]:
    # Use git-indexed files to avoid hashing build artifacts (e.g. .so, __pycache__),
    # which can appear locally but aren't part of the source distribution.
    try:
        out = subprocess.check_output(
            ["git", "-C", str(REPO_ROOT), "ls-files", "-z", *WHEEL_INPUT_PREFIXES],
            stderr=subprocess.DEVNULL,
        )
    except Exception:
        return []

    files: list[pathlib.Path] = []
    for raw in out.split(b"\0"):
        if not raw:
            continue
        p = REPO_ROOT / raw.decode("utf-8")
        if p.is_file():
            files.append(p)
    return files


def _hash_inputs() -> tuple[str, int]:
    h = hashlib.sha256()
    files = _git_tracked_files()
    if not files:
        raise RuntimeError(
            "Could not find git-tracked inputs for stamp; run from a git checkout."
        )

    # Deterministic ordering, stable across platforms.
    files = sorted(set(files), key=lambda p: p.relative_to(REPO_ROOT).as_posix())

    for p in files:
        rel = p.relative_to(REPO_ROOT).as_posix().encode("utf-8")
        h.update(rel)
        h.update(b"\0")
        h.update(p.read_bytes())
        h.update(b"\0")

    return h.hexdigest(), len(files)


def _read_stamp_sha256() -> str | None:
    if not STAMP_PATH.exists():
        return None
    for line in STAMP_PATH.read_text(encoding="utf-8").splitlines():
        if line.startswith("sha256:"):
            return line.split(":", 1)[1].strip()
    return None


def _write_stamp(sha256: str, *, file_count: int) -> None:
    STAMP_PATH.write_text(
        "\n".join(
            [
                "# Autogenerated by scripts/update_python_wheel_stamp.py",
                "# Hash of Python wheel sources (python/src + packaging metadata).",
                f"# inputs: {file_count} files",
                f"sha256: {sha256}",
                "",
            ]
        ),
        encoding="utf-8",
    )


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser(
        description="Update/verify the stamp that makes python-only changes visible to release automation."
    )
    ap.add_argument(
        "--check",
        action="store_true",
        help="Verify the stamp matches current python wheel inputs.",
    )
    args = ap.parse_args(argv)

    sha, n = _hash_inputs()
    current = _read_stamp_sha256()

    if args.check:
        if current == sha:
            return 0
        sys.stderr.write("python wheel stamp is out of date.\n")
        sys.stderr.write(f"expected sha256: {sha}\n")
        sys.stderr.write(f"current  sha256: {current or '<missing>'}\n")
        sys.stderr.write("\nFix:\n")
        sys.stderr.write("  python scripts/update_python_wheel_stamp.py\n")
        return 1

    _write_stamp(sha, file_count=n)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
